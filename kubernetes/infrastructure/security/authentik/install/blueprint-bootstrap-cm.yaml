apiVersion: v1
kind: ConfigMap
metadata:
  name: authentik-blueprints-bootstrap
  namespace: authentik
data:
  100-bootstrap.yaml: |
    version: 1
    metadata:
      name: homelab-bootstrap
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # 1. Create the Admin User
      - model: authentik_core.user
        state: present
        identifiers:
          username: !Env AK_BLUEPRINT_USER
        attrs:
          name: !Env AK_BLUEPRINT_USER
          email: "${ACME_EMAIL}"
          is_active: true
          is_superuser: true  # This ensures the Admin Console is visible
          password: !Env AK_BLUEPRINT_USER_PASSWORD

      # 2. Ensure user is in the "authentik Admins" group
      - model: authentik_core.group
        identifiers:
          name: "authentik Admins"
        attrs:
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # 3. Define the Proxy Provider
      - model: authentik_providers_proxy.proxyprovider
        id: proxy-provider
        identifiers:
          name: "Traefik-Gatekeeper"
        attrs:
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          mode: forward_domain
          external_host: "https://sso.${CLUSTER_DOMAIN}"
          domain: "${CLUSTER_DOMAIN}"
          cookie_domain: "${CLUSTER_DOMAIN}"
          internal_host: ""
          internal_host_ssl_validation: true
          skip_path_regex: ""
          access_token_validity: "hours=24"
          refresh_token_validity: "days=30"

      # 4. Define the Application
      - model: authentik_core.application
        identifiers:
          slug: "gatekeeper"
        attrs:
          name: "Gatekeeper"
          provider: !KeyOf proxy-provider

  110-proxy-scope-mapping.yaml: |
    version: 1
    metadata:
      name: proxy-scope-mapping
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Default ak-proxy scope mapping used by proxy providers
      - model: authentik_providers_oauth2.scopemapping
        state: present
        id: ak-proxy-mapping
        identifiers:
          scope_name: "ak-proxy"
        attrs:
          name: "Proxy Outpost"
          description: "Default proxy scope mapping"
          expression: |
            return {
                "ak_proxy": {
                    "user_attributes": {
                        "username": request.user.username,
                        "email": request.user.email,
                        "name": request.user.name,
                        "uid": str(request.user.uuid),
                        "groups": [g.name for g in request.user.ak_groups.all()],
                    }
                }
            }

  200-grafana.yaml: |
    version: 1
    metadata:
      name: grafana-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Create Grafana Admins and assign the bootstrap user
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Grafana Admins"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # Create Grafana Editors (currently empty)
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Grafana Editors"
        attrs:
          is_superuser: false
          parent: null

      - model: authentik_providers_oauth2.oauth2provider
        id: grafana-provider
        identifiers:
          name: "Grafana"
        attrs:
          client_id: !Env GRAFANA_CLIENT_ID
          client_secret: !Env GRAFANA_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-explicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "https://grafana.lan.${CLUSTER_DOMAIN}/login/generic_oauth"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, email]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]

      - model: authentik_core.application
        identifiers:
          slug: "grafana"
        attrs:
          name: "Grafana"
          provider: !KeyOf grafana-provider
          group: "Observability"

  210-vaultwarden.yaml: |
    version: 1
    metadata:
      name: vaultwarden-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Vaultwarden Users"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      - model: authentik_providers_oauth2.scopemapping
        id: vaultwarden-email-scope
        identifiers:
          name: "Vaultwarden Email Scope"
        attrs:
          scope_name: email
          description: "Vaultwarden email scope mapping"
          expression: |
            return {"email": request.user.email, "email_verified": True}

      - model: authentik_providers_oauth2.oauth2provider
        id: vaultwarden-provider
        identifiers:
          name: "Vaultwarden"
        attrs:
          client_id: !Env VAULTWARDEN_CLIENT_ID
          client_secret: !Env VAULTWARDEN_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-explicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "https://vault.${CLUSTER_DOMAIN}/identity/connect/oidc-signin"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !KeyOf vaultwarden-email-scope
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, offline_access]]

      - model: authentik_core.application
        identifiers:
          slug: "vaultwarden"
        attrs:
          name: "Vaultwarden"
          provider: !KeyOf vaultwarden-provider
          group: "Security"

      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "vaultwarden"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Vaultwarden Users"]]

  220-audiobookshelf.yaml: |
    version: 1
    metadata:
      name: audiobookshelf-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Media"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      - model: authentik_providers_oauth2.oauth2provider
        id: audiobookshelf-provider
        identifiers:
          name: "Audiobookshelf"
        attrs:
          client_id: !Env AUDIOBOOKSHELF_CLIENT_ID
          client_secret: !Env AUDIOBOOKSHELF_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          jwt_algorithm: RS256
          signing_key: !Find [authentik_crypto.certificatekeypair, [name, "authentik Self-signed Certificate"]]
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "https://audiobooks.lan.${CLUSTER_DOMAIN}/auth/openid/callback"
              matching_mode: strict
            - url: "https://audiobooks.lan.${CLUSTER_DOMAIN}/auth/openid/mobile-redirect"
              matching_mode: strict
            - url: "audiobookshelf://oauth"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, email]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]

      - model: authentik_core.application
        identifiers:
          slug: "audiobookshelf"
        attrs:
          name: "Audiobookshelf"
          provider: !KeyOf audiobookshelf-provider
          group: "Media"

      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "audiobookshelf"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Media"]]

  230-komga.yaml: |
    version: 1
    metadata:
      name: komga-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      - model: authentik_providers_oauth2.oauth2provider
        id: komga-provider
        identifiers:
          name: "Komga"
        attrs:
          client_id: !Env KOMGA_CLIENT_ID
          client_secret: !Env KOMGA_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          jwt_algorithm: RS256
          signing_key: !Find [authentik_crypto.certificatekeypair, [name, "authentik Self-signed Certificate"]]
          encryption_key: null
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "https://comics.lan.${CLUSTER_DOMAIN}/login/oauth2/code/authentik"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !Find [authentik_providers_oauth2.scopemapping, [name, "Vaultwarden Email Scope"]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]

      - model: authentik_core.application
        identifiers:
          slug: "komga"
        attrs:
          name: "Komga"
          provider: !KeyOf komga-provider
          group: "Media"

      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "komga"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Media"]]

  240-gitea.yaml: |
    version: 1
    metadata:
      name: gitea-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Create gituser group (normal Gitea users)
      - model: authentik_core.group
        state: present
        identifiers:
          name: "gituser"
        attrs:
          is_superuser: false
          parent: null

      # Create gitadmin group with default user (Gitea administrators)
      - model: authentik_core.group
        state: present
        identifiers:
          name: "gitadmin"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # Create custom scope mapping for Gitea role claims
      - model: authentik_providers_oauth2.scopemapping
        id: gitea-scope
        identifiers:
          name: "Gitea Role Scope"
        attrs:
          scope_name: gitea
          description: "Gitea role claim based on group membership"
          expression: |
            gitea_claims = {}
            if request.user.ak_groups.filter(name="gituser").exists():
                gitea_claims["gitea"] = "user"
            if request.user.ak_groups.filter(name="gitadmin").exists():
                gitea_claims["gitea"] = "admin"
            return gitea_claims

      # Create OAuth2 Provider for Gitea
      - model: authentik_providers_oauth2.oauth2provider
        id: gitea-provider
        identifiers:
          name: "Gitea"
        attrs:
          client_id: !Env GITEA_CLIENT_ID
          client_secret: !Env GITEA_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          jwt_algorithm: RS256
          signing_key: !Find [authentik_crypto.certificatekeypair, [name, "authentik Self-signed Certificate"]]
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "https://git.${CLUSTER_DOMAIN}/user/oauth2/Authentik/callback"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, email]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]
            - !KeyOf gitea-scope

      # Create Gitea Application
      - model: authentik_core.application
        identifiers:
          slug: "gitea"
        attrs:
          name: "Gitea"
          provider: !KeyOf gitea-provider
          group: "Development"

      # Restrict access to gituser group members
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "gitea"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "gituser"]]

      # Also allow gitadmin group members
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "gitea"]]
          order: 1
        attrs:
          group: !Find [authentik_core.group, [name, "gitadmin"]]

  250-paperless.yaml: |
    version: 1
    metadata:
      name: paperless-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Paperless Users group
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Paperless Users"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # OAuth2 Provider for Paperless
      - model: authentik_providers_oauth2.oauth2provider
        id: paperless-provider
        identifiers:
          name: "Paperless"
        attrs:
          client_id: !Env PAPERLESS_CLIENT_ID
          client_secret: !Env PAPERLESS_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          encryption_key: null
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "https://docs.lan.${CLUSTER_DOMAIN}/accounts/oidc/authentik/login/callback/"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, email]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]

      # Paperless Application
      - model: authentik_core.application
        identifiers:
          slug: "paperless"
        attrs:
          name: "Paperless"
          provider: !KeyOf paperless-provider
          group: "Utils"

      # Restrict access to Paperless Users
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "paperless"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Paperless Users"]]

  500-frigate.yaml: |
    version: 1
    metadata:
      name: frigate-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Frigate Admins group
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Frigate Admins"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # Frigate Viewers group
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Frigate Viewers"
        attrs:
          is_superuser: false
          parent: null

      # Custom scope mapping that transforms Frigate groups to roles
      - model: authentik_providers_oauth2.scopemapping
        state: present
        id: frigate-role-mapping
        identifiers:
          name: "Frigate Role Mapping"
        attrs:
          scope_name: frigate-role
          description: "Maps Frigate Admins/Viewers groups to admin/viewer role"
          expression: |
            import os
            role = None
            if request.user.ak_groups.filter(name="Frigate Admins").exists():
                role = "admin"
            elif request.user.ak_groups.filter(name="Frigate Viewers").exists():
                role = "viewer"
            secret = os.environ.get("FRIGATE_PROXY_SECRET", "")
            headers = {}
            if role:
                headers["X-authentik-groups"] = role
            if secret:
                headers["X-Proxy-Secret"] = secret
            return {
                "ak_proxy": {
                    "user_attributes": {
                        "additionalHeaders": headers
                    }
                }
            }

      # Frigate Proxy Provider
      - model: authentik_providers_proxy.proxyprovider
        id: frigate-provider
        identifiers:
          name: "Frigate"
        attrs:
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          mode: forward_single
          external_host: "https://frigate.lan.${CLUSTER_DOMAIN}"
          access_token_validity: "hours=24"
          refresh_token_validity: "days=30"
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, "ak-proxy"]]
            - !Find [authentik_providers_oauth2.scopemapping, [name, "Frigate Role Mapping"]]

      # Frigate Application
      - model: authentik_core.application
        identifiers:
          slug: "frigate"
        attrs:
          name: "Frigate"
          provider: !KeyOf frigate-provider
          group: "Security"

      # Restrict access to Frigate Admins
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "frigate"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Frigate Admins"]]

      # Restrict access to Frigate Viewers
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "frigate"]]
          order: 1
        attrs:
          group: !Find [authentik_core.group, [name, "Frigate Viewers"]]

  510-discord.yaml: |
    version: 1
    metadata:
      name: discord-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Discord Users group
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Discord Users"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # Custom scope mapping that injects Authorization header
      - model: authentik_providers_oauth2.scopemapping
        state: present
        id: discord-auth-mapping
        identifiers:
          name: "Discord Auth Mapping"
        attrs:
          scope_name: discord-auth
          description: "Injects basic auth header for Kasm bypass"
          expression: |
            import os
            basic_auth = os.environ.get("DISCORD_BASIC_AUTH", "")
            headers = {}
            if basic_auth:
                headers["Authorization"] = basic_auth
            return {
                "ak_proxy": {
                    "user_attributes": {
                        "additionalHeaders": headers
                    }
                }
            }

      # Discord Main Proxy Provider
      - model: authentik_providers_proxy.proxyprovider
        id: discord-main-provider
        identifiers:
          name: "Discord Main"
        attrs:
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          mode: forward_single
          external_host: "https://discord1.lan.${CLUSTER_DOMAIN}"
          access_token_validity: "hours=24"
          refresh_token_validity: "days=30"
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, "ak-proxy"]]
            - !Find [authentik_providers_oauth2.scopemapping, [name, "Discord Auth Mapping"]]

      # Discord Alternate Proxy Provider
      - model: authentik_providers_proxy.proxyprovider
        id: discord-alternate-provider
        identifiers:
          name: "Discord Alternate"
        attrs:
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          mode: forward_single
          external_host: "https://discord2.lan.${CLUSTER_DOMAIN}"
          access_token_validity: "hours=24"
          refresh_token_validity: "days=30"
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, "ak-proxy"]]
            - !Find [authentik_providers_oauth2.scopemapping, [name, "Discord Auth Mapping"]]

      # Discord Main Application
      - model: authentik_core.application
        identifiers:
          slug: "discord-main"
        attrs:
          name: "Discord Main"
          provider: !KeyOf discord-main-provider
          group: "Utils"

      # Discord Alternate Application
      - model: authentik_core.application
        identifiers:
          slug: "discord-alternate"
        attrs:
          name: "Discord Alternate"
          provider: !KeyOf discord-alternate-provider
          group: "Utils"

      # Restrict Discord Main to Discord Users group
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "discord-main"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Discord Users"]]

      # Restrict Discord Alternate to Discord Users group
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "discord-alternate"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Discord Users"]]

  250-immich.yaml: |
    version: 1
    metadata:
      name: immich-sso
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Immich Admins group (your user gets admin role)
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Immich Admins"
        attrs:
          is_superuser: false
          parent: null
          users:
            - !Find [authentik_core.user, [username, !Env AK_BLUEPRINT_USER]]

      # Immich Users group (regular users)
      - model: authentik_core.group
        state: present
        identifiers:
          name: "Immich Users"
        attrs:
          is_superuser: false
          parent: null

      # Custom scope mapping for immich_role claim
      - model: authentik_providers_oauth2.scopemapping
        id: immich-role-scope
        identifiers:
          name: "Immich Role Scope"
        attrs:
          scope_name: immich_role
          description: "Immich role claim based on group membership"
          expression: |
            immich_claims = {}
            if request.user.ak_groups.filter(name="Immich Admins").exists():
                immich_claims["immich_role"] = "admin"
            elif request.user.ak_groups.filter(name="Immich Users").exists():
                immich_claims["immich_role"] = "user"
            return immich_claims

      - model: authentik_providers_oauth2.oauth2provider
        id: immich-provider
        identifiers:
          name: "Immich"
        attrs:
          client_id: !Env IMMICH_CLIENT_ID
          client_secret: !Env IMMICH_CLIENT_SECRET
          authorization_flow: !Find [authentik_flows.flow, [slug, default-provider-authorization-implicit-consent]]
          invalidation_flow: !Find [authentik_flows.flow, [slug, default-provider-invalidation-flow]]
          jwt_algorithm: RS256
          signing_key: !Find [authentik_crypto.certificatekeypair, [name, "authentik Self-signed Certificate"]]
          client_type: confidential
          client_authentication_method: client_secret_post
          redirect_uris:
            - url: "app.immich:///oauth-callback"
              matching_mode: strict
            - url: "https://photos.${CLUSTER_DOMAIN}/auth/login"
              matching_mode: strict
            - url: "https://photos.${CLUSTER_DOMAIN}/user-settings"
              matching_mode: strict
          property_mappings:
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, openid]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, email]]
            - !Find [authentik_providers_oauth2.scopemapping, [scope_name, profile]]
            - !KeyOf immich-role-scope

      - model: authentik_core.application
        identifiers:
          slug: "immich"
        attrs:
          name: "Immich"
          provider: !KeyOf immich-provider
          group: "Media"
          meta_launch_url: "https://photos.${CLUSTER_DOMAIN}/auth/login?autoLaunch=1"

      # Allow Immich Users
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "immich"]]
          order: 0
        attrs:
          group: !Find [authentik_core.group, [name, "Immich Users"]]

      # Allow Immich Admins
      - model: authentik_policies.policybinding
        identifiers:
          target: !Find [authentik_core.application, [slug, "immich"]]
          order: 1
        attrs:
          group: !Find [authentik_core.group, [name, "Immich Admins"]]

  999-outpost.yaml: |
    version: 1
    metadata:
      name: outpost-assembly
      labels:
        blueprints.goauthentik.io/instantiate: "true"
    entries:
      # Shared proxy outpost for all proxy providers
      # IMPORTANT: This MUST be the last blueprint to run (99- prefix)
      # All proxy providers must be defined BEFORE this outpost is created
      # Blueprint attrs REPLACE entire objects, not merge - defining outpost
      # in multiple files will wipe configuration from earlier definitions
      - model: authentik_outposts.outpost
        identifiers:
          name: "gatekeeper-proxy"
        attrs:
          type: "proxy"
          service_connection: !Find [authentik_outposts.kubernetesserviceconnection, [name, "Local Kubernetes Cluster"]]
          providers:
            - !Find [authentik_providers_proxy.proxyprovider, [name, "Traefik-Gatekeeper"]]
            - !Find [authentik_providers_proxy.proxyprovider, [name, "Frigate"]]
            - !Find [authentik_providers_proxy.proxyprovider, [name, "Discord Main"]]
            - !Find [authentik_providers_proxy.proxyprovider, [name, "Discord Alternate"]]
          config:
            authentik_host: "http://authentik-server.authentik.svc.cluster.local"
            authentik_host_browser: "https://sso.${CLUSTER_DOMAIN}"
            log_level: debug
            object_naming_template: "ak-outpost-%(name)s"
            kubernetes_replicas: 1
            kubernetes_service_type: ClusterIP
            kubernetes_ingress_secret_name: wildcard-cluster-domain-tls
            kubernetes_disabled_components:
              - traefik middleware
            cookie_token_duration: 86400
